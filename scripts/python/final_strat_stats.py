# -*- coding: utf-8 -*-
"""final_strat_stats.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1e719svqdDu79SdLw1kzJ34zLONrVtJEb
"""

# ─── Cell 1: Setup – imports, style, mappings ─────────────────────────────
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# 1) Seaborn style for academic clarity
sns.set_context("paper", font_scale=1.2)
sns.set_style("whitegrid")
sns.set_palette("colorblind")

# 2) Display names for metrics
display_names = {
    'flesch_score':         'Flesch Reading Ease',
    'fk_grade':             'Flesch-Kincaid Grade Level',
    'fog_index':            'Gunning Fog Index',
    'smog_index':           'SMOG Index',
    'avg_sentence_length':  'Average Sentence Length',
    'word_count':           'Word Count',
    'passive_ratio':        'Passive Voice Ratio',
    'hedging_percent':      'Hedging Percentage',
    'lexical_density':      'Lexical Density'
}

# 3) Axis labels with units or ranges
axis_labels = {
    'flesch_score':         'Flesch Reading Ease (Score 0–100)',
    'fk_grade':             'Flesch-Kincaid Grade Level (U.S. School Grade)',
    'fog_index':            'Gunning Fog Index (U.S. School Grade)',
    'smog_index':           'SMOG Index (Approx. Years of Education)',
    'avg_sentence_length':  'Average Sentence Length (Words / Sentence)',
    'word_count':           'Word Count (Tokens)',
    'passive_ratio':        'Passive Voice Ratio (0.0–1.0)',
    'hedging_percent':      'Hedging Percentage (0.0–1.0)',
    'lexical_density':      'Lexical Density (% Content Words)'
}

# ─── Cell 2: Upload your merged CSV ───────────────────────────────────────
from google.colab import files
print("Upload 'combined_abstracts.csv'")
files.upload()  # pick combined_abstracts.csv

# ─── Cell 3: Load & preprocess ───────────────────────────────────────────
df = pd.read_csv('combined_abstracts.csv')

# Rename columns to snake_case
df.rename(columns={
    'Flesch Reading Ease':        'flesch_score',
    'Flesch-Kincaid Grade Level': 'fk_grade',
    'Gunning Fog Index':          'fog_index',
    'SMOG Index':                 'smog_index',
    'Average Sentence Length':    'avg_sentence_length',
    'Word Count':                 'word_count',
    'Passive Voice Ratio':        'passive_ratio',
    'Hedging %':                  'hedging_percent',
    'Lexical Density':            'lexical_density'
}, inplace=True)

# Bucket years into decades
df['decade'] = (df['Year']//10*10).astype(int).astype(str) + 's'

# ─── Cell 4: Inspect strata sizes ────────────────────────────────────────
strata = df.groupby(['decade','Access_Type']).size().unstack(fill_value=0)
print("Counts per decade & access type:")
print(strata)

# ─── Cell 5: Determine sample size per stratum ───────────────────────────
# Choose the minimum count across all decade×access strata
min_n = strata.values.min()
print(f"Balanced sampling n = {min_n} per (decade, Access_Type)")

# Or hardcode your own: e.g., n=500
# min_n = 500

# ─── Cell 6: Perform stratified sampling ────────────────────────────────
sampled = (
    df
    .groupby(['decade','Access_Type'], group_keys=False)
    .apply(lambda g: g.sample(n=min_n, random_state=42))
    .reset_index(drop=True)
)
print(f"Sampled dataframe shape: {sampled.shape}")

# ─── Cell 7: Define metrics & check availability ─────────────────────────
metrics = list(display_names.keys())
available = [m for m in metrics if m in sampled.columns]
missing   = set(metrics) - set(available)
if missing:
    print(f"Missing columns: {missing}")
print("Metrics:", available)

# ─── Cell 8: Aggregate sampled data ──────────────────────────────────────
# Compute mean, median, std, sem by decade & access
agg_funcs = ['mean','median','std']
agg = sampled.groupby(['decade','Access_Type'])[available].agg(agg_funcs)
agg.columns = ['_'.join(c) for c in agg.columns]
agg_df = agg.reset_index()

# add counts and sem
counts = sampled.groupby(['decade','Access_Type']).size().rename('n').reset_index()
agg_df = agg_df.merge(counts, on=['decade','Access_Type'])
for m in available:
    agg_df[f"{m}_se"] = agg_df[f"{m}_std"]/np.sqrt(agg_df['n'])

print("Aggregated sampled stats ready.")

# ─── Cell 9: Trend lines (SE) for sampled data ──────────────────────────
decades = sorted(agg_df['decade'].unique(), key=lambda x: int(x[:-1]))

for m in available:
    plt.figure(figsize=(8,5))
    for atype, style, marker in zip(['C','OA'], ['-', '--'], ['o','s']):
        sub=agg_df[agg_df['Access_Type']==atype].set_index('decade').loc[decades]
        x=np.arange(len(decades))
        y=sub[f"{m}_mean"]; yerr=sub[f"{m}_se"]
        label = "Conventional" if atype=='C' else "Open Access"
        plt.errorbar(x,y,yerr=yerr, fmt=style+marker, capsize=3,
                     linewidth=1.5, markersize=6,
                     label=f"{label} (n={sub['n'].iloc[0]})")
    plt.xticks(x,decades,rotation=45)
    plt.xlabel('Decade')
    plt.ylabel(axis_labels[m])
    plt.title(f"{display_names[m]} by Decade (Stratified Sample)")
    plt.legend(title="Access Type", frameon=True)
    plt.tight_layout()
    plt.savefig(f"{m}_stratified_trend.png", dpi=300)
    plt.savefig(f"{m}_stratified_trend.svg")
    plt.show()

# ─── Cell 10: Boxplots by Decade (sampled, SD overlay & mean) ───────────
for m in available:
    plt.figure(figsize=(8,5))
    sns.boxplot(x='decade', y=m, data=sampled, showfliers=True)
    stats = sampled.groupby('decade')[m].agg(['mean','std'])
    x_pos = np.arange(len(decades))
    plt.errorbar(x_pos, stats.loc[decades,'mean'],
                 yerr=stats.loc[decades,'std'],
                 fmt='D', color='red', markersize=5, label='Mean ±1 SD')
    plt.xticks(x_pos, decades, rotation=45)
    plt.xlabel('Decade')
    plt.ylabel(axis_labels[m])
    plt.title(f"{display_names[m]} Distribution by Decade (Stratified Sample)")
    plt.legend(frameon=True)
    plt.tight_layout()
    plt.savefig(f"{m}_stratified_box_decade.png", dpi=300)
    plt.show()

# ─── Cell 11: Boxplots by Access Type (sampled, SD overlay & mean) ───────
order = ['C','OA']
for m in available:
    plt.figure(figsize=(6,5))
    sns.boxplot(x='Access_Type', y=m, data=sampled, order=order, showfliers=True)
    stats = sampled.groupby('Access_Type')[m].agg(['mean','std'])
    x_pos = [0,1]
    plt.errorbar(x_pos, stats.loc[order,'mean'],
                 yerr=stats.loc[order,'std'],
                 fmt='D', color='red', markersize=5, label='Mean ±1 SD')
    plt.xticks(x_pos, ['Conventional','Open Access'])
    plt.xlabel('Access Type')
    plt.ylabel(axis_labels[m])
    plt.title(f"{display_names[m]} Distribution by Access Type (Stratified Sample)")
    plt.legend(frameon=True)
    plt.tight_layout()
    plt.savefig(f"{m}_stratified_box_access.png", dpi=300)
    plt.show()

# ─── Cell 12: Notes & Best Practices for Stratified Trends ───────────────
1. **Balanced Sample**: Stratified sampling ensures equal n per decade×access, reducing bias from uneven publication rates.
2. **Standard Error for Trends**: Reflects precision of the mean when comparing balanced strata.
3. **SD in Boxplots**: Shows within-stratum variability directly.
4. **Colorblind Palette**: Maintains accessibility.
5. **Gridlines & Font**: Use light grids and consistent font sizes for legibility at journal print size.
6. **High-Res & Vector Exports**: PNG at 300 dpi + SVG ensure crisp reproduction.
7. **Captioning**: Always state “Stratified sample: n per stratum = X” and define error bars (±1 SE in trend, ±1 SD in boxplots).
8. **Statistical Tests** *(optional)*: For formal significance, pairwise decade comparisons or regression p‐values can be added.

*Run Cells 1→12 in order to perform stratified sampling and reproduce publication-quality figures.*